\newpage

# 提案

本節では，前節で明らかにしたSDN-MPIの課題を踏まえ，MPIアプリケーションの実行に
同期してネットワーク制御するための手法を提案する．

## 提案手法の概要

本報告の提案手法の基本的な考え方は，MPIが送出する各パケットに通信パターン
をエンコードしたタグを付与し，タグに基いてネットワークでパケット制御することに
ある．図 \ref{fig:proposal-arch}に提案手法のアーキテクチャを示す．各計算ノード
は，ユーザ空間で1つ以上のMPIアプリケーションのプロセスを実行する．MPIアプリ
ケーションは，MPIライブラリを動的にリンクしている．計算ノードのカーネル空間に
は，「タグ付けカーネルモジュール」が常駐し，MPIライブラリが送出するパケットに
，タグ付け処理を実行する．MPIライブラリとカーネルモジュールは連携動作し，タグ
付けに必要なMPIライブラリ内部の情報を共有する．

SDNコントローラは，MPIパケットのタグに基づいて，パケットを制御するフローエント
リを各スイッチのフローテーブルに登録する．スイッチはMPIパケットを受信すると
パケットのタグを読み取り，フローテーブルにしたがってパケットを処理する．受信側
の計算ノードに隣接するスイッチは，計算ノードにパケットを転送する前に，タグを除
去する．なお，本報告では前提とするSDNの実装はOpenFlowである．

![提案手法の全体像の概要\label{fig:proposal-arch}](proposal-arch.pdf)

\newpage

タグ付けカーネルモジュールは，MPIというアプリケーションのレイヤの情報をSDNで取
り扱えるように，タグという形でパケットに埋め込む役割を担っている．パケット自身
にMPI通信パターンが書き込まれているため，SDNコントローラやスイッチは，MPIアプ
リケーションと別途通信することなく，各々のパケットに対する制御を決定
できる．これが，本提案手法により低オーバーヘッドなMPIアプリケーションとネット
ワーク制御の同期が可能になる本質的な理由である．

## タグ付けカーネルモジュール

### タグの格納場所

提案手法では，タグをMPIパケットのMACアドレスフィールドに書き込む．

これはスイッチが，タグに基づくパケット制御を効率的に実行できるようにするための
工夫である．OpenFlowスイッチが取り扱えるヘッダフィールドは，OpenFlow規格で定義
されたフィールドに限られる．事前定義されていないヘッダフィールドを読み取る場合
は，毎回SDNコントローラへパケットを転送する必要があり，オーバーヘッドが非常に
大きい．したがって，タグを埋め込むヘッダフィールドはOpenFlow規格で定義されてい
るものの中から選ぶのが望ましい．MACアドレスフィールドは，OpenFlow規格において
定義されているヘッダフィールドである．

さらに，スイッチに登録できるフローの数が増えるという利点がある．OpenFlowスイッ
チのフローテーブルに登録できるフローの数には上限があり，一般的なOpenFlowスイッ
チでは数千個のオーダである．ところが，多くのOpenFlowスイッチはL2ヘッダフィール
ド（MACアドレスとVLAN ID）のみ含むフローに関しては数万個登録できる．よって，タ
グをパケットをMACアドレスに格納することで，他のヘッダフィールドに格納するより
も，フロー数の上限を増やせる．

### MACアドレスの書き換え

提案手法では，MPI通信パターンに応じてパケットを動的にタグ付けするので，動的に
MPIパケットのMACアドレスを書き換える必要がある．

動的にパケットのMACアドレスを変える方法として，Rawソケットを用いる方法がある．
Rawソケットは，ユーザ空間のプログラムからパケットのプロトコルヘッダを読み書き
可能にする特殊なソケットである．Rawソケットを用いれば，L2ヘッダを自由に構成し
てパケットを送信できる．一方で，ユーザ空間でTCP/IPスタックを全て再実装する必要
があり，非現実的である．また，MPIライブラリをRawソケットを使用するように大きく
修正する必要があることや，アプリケーションがroot権限で実行されなければいけない
などの欠点もある．

Linuxにおいて，パケットのフィルタリングや改変のためには，Linuxカーネルが提供す
るnetfilter APIが一般的に用いられる．実際，Linuxにおけるファイアーウォールや
NATは，内部でnetfilterを使用している．Netfilterは，プログラムがカーネルのネッ
トワークスタックの特定の場所にフックし，独自の処理を挿入することを可能にする．
しかし，フックできる場所は事前定義された場所に限られ，カーネルがパケットにL2
ヘッダを付与するのは，netfilterでフック可能な場所を通過した後である．そのため
，netfilterではパケットのMACアドレスを書き換えることはできない．

以上の議論を踏まえて，提案手法では，プロトコルハンドラを実装することでMACアド
レスの書き換えを実現している．プロトコルハンドラは，パケットがNIC（Network
Interface Card）から到着した直後と，NICへ送信される直前にカーネルが呼び出す
コールバック関数である．プロトコルハンドラは，カーネル空間で実行されるため，
カーネルモジュール\cite{Goyeneche1999}に実装する．プロトコルハンドラでは，NIC
へ送信するパケット全体を取得し，書き換えることができるため，タグ付けを実装する
できる．

### MPIパケットの識別

プロトコルハンドラは，カーネルのネットワークスタックが送出する全てのパケットに
ついて呼び出される．つまり，MPIライブラリ以外によって送信されたパケット，例え
ば計算ノードの制御に用いられるSSHのパケットについてもプロトコルハンドラが呼び
出される．よって，タグ付け処理の前段階として，プロトコルハンドラに渡されたパ
ケットがMPIライブラリに由来するものか判定しなければいけない．提案手法では，あ
るパケットがMPIに由来するかの判定条件として，それぞれのMPIプロセスの組について
ユニークである，下記の4つ組を用いている：

- 送信元IPアドレス
- 宛先IPアドレス
- 送信元TCPポート番号
- 宛先TCPポート番号

以下では，この4つ組を「ピア情報」と呼ぶ．具体的な識別処理の手順は次の通りであ
る．MPIプロセス間でTCP接続が確立する度に，ピア情報をリストに追加していく．これ
を「ピアリスト」と呼ぶ．そして，プロトコルハンドラがパケットを受信すると，その
パケットからピア情報を抽出し，ピア情報がピアリストに含まれているか確認する．ピ
アリストに含まれていれば，パケットはMPIライブラリによって送出されたパケットで
あるから，タグ付け処理に続行する．ピアリストに含まれていなければ，単純に無視す
る．

### MPIライブラリとの連係

ここで，タグ付けカーネルモジュールが，MPIプロセス間でTCP接続が確立したことを
どのように検知するかという問題がある．提案手法では，これをMPIライブラリとタグ
付けカーネルモジュールの連係により実現する．具体的には，MPIライブラリがMPIプロ
セス間でTCP接続を確立した際に，タグ付けカーネルモジュールに前述のピア情報を通
知する．本提案手法における各コンポーネントの相互作用を図にまとめると，図
\ref{fig:mpi-lkm}の通りになる．なお，実線はコンポーネントの連係を，点線矢印は
パケットの流れを表す．

![タグ付けカーネルモジュールとMPIライブラリの連係\label{fig:mpi-lkm}](mpi-lkm.pdf)

ユーザ空間のプログラムとカーネルモジュールの間の通信には様々な実現方法があるが
，転送するデータサイズが小さいことと，実装の容易さを考慮し，ここでは`ioctl`シ
ステムコールを採用した．`ioctl`は，ユーザプログラムからデバイスドライバを制御
するためのシステムコールである．

具体的な連係手順は次の通りである．タグ付けカーネルモジュールは，miscキャラクタ
デバイスとして振る舞い，`/dev/sdnmpi`にデバイスファイルを公開する．MPIライブラ
リは，初期化時に`/dev/sdnmpi`デバイスを開き，ファイルハンドルを保持しておく．
そして，MPIプロセス間でTCP接続が確立した際（`connect`あるいは`accept`関数成功
時）に，`/dev/sdnmpi`デバイスに対して`ioctl`システムコールを発行し，ピア情報を
引数として渡す．カーネルモジュール側では，`ioctl`システムコールのハンドラでピ
ア情報を受信し，ピアリストに追加する．

## SDNコントローラ

